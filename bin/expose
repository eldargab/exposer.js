#!/usr/bin/env node

var program = require('commander')

program.version('0.0.0')

program
    .option('-r, --root [dir]', 'Base dir to determine module names. Defaults to cwd.')
    .option('-t, --target <dirOrFile>', 'Target directory (or file) for compiled modules.')
    .option('-i, --ignore [patterns]', '.gitignore style rules for ingoring paths', list)
    .option('-R, --recompile', 'Recompile even if target is uptodate')

program
    .command('* <path>')
    .description('Expose modules under the <path>. <path> should be specified relative to --root dir')
    .action(function (path) {
        Compile('Expose', path)
    })

program
    .command('bundle <path>')
    .description('Bundle modules under the <path> into a single script')
    .option('--include-require')
    .option('--include-async-require')
    .option('-m, --main <file>', 'Add `return require("main")` at the end of bundle`s closure')
    .option('-v, --var <name>', 'Set result to `var name`')
    .action(function (path, options) {
        Compile('Bundle', path, options)
    })

program.parse(process.argv)

function Compile (method, path, options) {
    if (!program.target) throw new Error('--target option not specified')
    var Compile = require('..')[method]
    Compile(program.target, function () {
        this.recompile = program.recompile
        mix(this, options)
        this.add(program.root || '.', path, program.ignore)
    })
}

function mix (t, src) {
    if (!src) return
    for (var key in src) {
        t[key] = src[key]
    }
}

function list (val) {
    return val.split(/\s*,\s*/g)
}